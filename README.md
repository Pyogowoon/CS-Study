# CS-Study




기술면접 대비


1\. 프로그래밍 공통 질문

**[ OOP란 ]**

OOP는 현실 세계를 프로그래밍으로 옮겨와 현실 세계의 사물들을 객체로 보고, 그 객체로부터 개발하고자 하는 특징과 기능을 뽑아와 프로그래밍하는 기법입니다. 

OOP로 코드를 작성하면 재사용성과 변형가능성을 높일 수 있습니다.

**[ OOP의 5가지 설계 원칙 ]**

•  SRP(Single Responsibility Principle, 단일 책임 원칙): 클래스는 단 하나의 목적을 가져야 하며, 클래스를 변경하는 이유는 단 하나의 이유여야 한다.

•  OCP(Open-Closed Principle, 개방 폐쇠 원칙): 클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.

•  LSP(Liskov Substitution Principle, 리스코프 치환 원칙): 상위 타입의 객체를 하위 타입으로 바꾸어도 프로그램은 일관되게 동작해야 한다.

•  ISP(Interface Segregation Principle, 인터페이스 분리 원칙): 클라이언트는 이용하지 않는 메소드에 의존하지 않도록 인터페이스를 분리해야 한다.

•  DIP(Dependency Inversion Principle, 의존 역전 법칙): 클라이언트는 추상화(인터페이스)에 의존해야 하며, 구체화(구현된 클래스)에 의존해선 안된다.

**[ 절차지향 프로그래밍 VS 객체지향 프로그래밍 ]**

•  절차지향 프로그래밍

•  물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다.

•  가장 대표적인 언어로 C언어가 있다.

•  컴퓨터의 처리구조와 유사해 실행속도가 빠르다.

•  코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.

•  객체지향 프로그래밍

•  실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법

•  가장 대표적인 언어로 Java가 있다.

•  캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.

•  절치지향 언어보다 실행속도가 느리다.


**[ RESTful API ]**

REST(REpresentational State Transfer)ful API는 HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다. RESTful API는 아래와 같은 것들로 구성됩니다.

•  Resource(자원, URI)

•  Method(요청 방식, GET or POST 등)

•  Representation of Resource(자원의 형태, JSON or XML 등)



**[ 함수형 프로그래밍 ]**

함수평 프로그래밍의 가장 큰 특징은 immutable data와 first class citizen으로서의 함수입니다. 함수형 프로그래밍은 부수효과가 없는 순수 함수를 이용하여 프로그램을 만드는 것이다. 부수 효과가 없는 순수 함수란 데이터의 값을 변경시키지 않으며 객체의 필드를 설정하는 등의 작업을 하지 않는 함수를 의미합니다.

**[ 메모리 구조 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.001.png)

•  코드 영역: 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부릅니다. 사용자가 프로그램 실행 명령을 내리면 OS가 HDD에서 메모리로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 처리하게 됩니다.

•  데이터 영역: 프로그램의 전역 변수(global)와 정적 변수(static)가 저장되는 영역입니다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

•  힙 영역: 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에 메모리를 할당하는 것을 동적 할당이라고 부릅니다. Java에서는 가비지 컬렉터가 자동으로 해제해줍니다. 힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당됩니다.

•  스택 영역: 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역입니다. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 합니다. 스택 영역은 함수의 호출이 완료되면 소멸합니다. 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됩니다.


` `**[ Parameter와 Argument의 차이 ]**

•  Parameter: 함수를 선언할 때 사용된 변수

•  Argument: 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값

**[ Call By Value와 Call By Reference 차이 ]**

•  Call By Value

•  인자로 받은 값을 복사하여 처리하는 방식

•  Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존된다.

•  값을 복사하여 넘기기 때문에 메모리 사용량이 늘어난다.

•  Call By Reference

•  인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식

•  값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.

•  원래의 값에 영향을 주는 리스크가 존재한다.

**[ 프레임워크와 라이브러리 차이 ]**

•  라이브러리: 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다.

•  프레임워크: 전체적인 흐름을 자체적으로 제어한다.

프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됩니다.

**[ 동기와 비동기의 차이 ]**

•  동기(Synchronous) 방식

•  요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식

•  순서에 맞추어 진행되기 때문에 제어하기 쉽다.

•  여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다.

•  동기 방식의 예시로는 콜센터 종업원이 일을 처리하는 방식이 될 수 있다. 콜센터의 직원은 한 손님의 전화 응대가 끝난 후에 다음 손님의 응대를 진행할 수 있다.

•  비동기(Asynchronous) 방식

•  요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식

•  작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있다.

•  작업이 완료된 결과를 제어하기 어렵다.

•  비동기 방식의 예제로는 이메일이 있다. 우리는 한 사람에게 이메일을 보냈을 때 답변을 받지 않고도 이메일을 다시 보낼 수 있다. 

**[ SQL Injection ]**

SQL Injection이란 공격자가 악의적인 의도를 갖는 구문을 삽입하여 공격자가 원하는 SQL을 실행하도록 하는 웹해킹기법입니다. 예를 들어 아래와 같은 간단한 SQL 문이 있을 때 INPUT1에 **'OR 1=1--**을 넣는 것입니다.

SELECT\* FROM USER WHERE ID= 'INPUT1' AND PASSWORD= 'INPUT2' SELECT\* FROM USER WHERE ID= '' OR 1=1 *--INPUT1' AND PASSWORD = 'INPUT2'*



INPUT1으로 **'OR 1=1--**을 넣으면 보이는 것처럼 뒤의 내용은 주석처리가 되고 WHERE 문은 항상 참이 됩니다.

이러한 공격을 방지하기 위해 특수문자 및 SQL 예약어들을 필터링하거나 SQL 오류 메세지를 노출하지 않는 등의 방법을 취해야 합니다.

**[ TDD(Test-Driven Development) ]**

TDD(Test-Driven Development)는 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로, 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 의미합니다.

개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 하기 때문에 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힙니다.



2\. 자료구조

**[ 자료구조와 알고리즘 ]**

자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고, 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임입니다.

**[ 스택, 큐, 트리, 힙 구조 설명 ]**

•  스택: 세로로 된 바구니와 같은 구조로 먼저 넣게 되는 자료가 마지막으로 나오게 되는 First-In Last-Out(FILO) 구조이다.

•  큐: 가로로 된 통과 같은 구조로 먼저 넣게 되는 자료가 가장 먼저 나오는 First-In First-Out(FIFO) 구조이다.

•  트리: 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태로, 계층이 있는 데이터를 표현하기에 적합하다.

•  힙: 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리이다.

**[ 우선순위 큐와 내부 구조 및 시간복잡도 ]**

우선순위큐는 가장 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다. 우선순위 큐를 구현하기 위해서 일반적으로 힙을 사용합니다. 힙은 완전이진트리를 통해서 구현되었기 때문에 우선순위 큐의 시간복잡도는 O(logn)입니다.

**[ 해시 테이블와 해시 테이블의 시간 복잡도 ]**

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다. 해시 테이블은 Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.



해시 테이블은 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다. 하지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가할 수 있습니다.

**[ LinkedList와 ArrayList 차이 ]**

ArrayList는 데이터들이 순서대로 늘어선 배열의 형식을 취하고 있지만, LinkedList는 자료의 주소값으로 서로 연결된 형식을 가지고 있습니다. 이러한 구조에 의해 둘은 각각의 장단점을 가지고 있습니다.

•  ArrayList

•  원하는 데이터에 무작위로 접근할 수 있다.

•  리스트의 크기가 제한되어 있으며, 리스트의 크기를 재조정하는 것은 많은 연산이 필요하다.

•  데이터의 추가/삭제를 위해서는 임시 배열을 생성하여 복제하고 있어 시간이 오래 걸린다.

•  LinkedList

•  리스트의 크기에 영향 없이 데이터를 추가할 수 있다.

•  데이터를 추가하기 위해 새로운 노드를 생성하여 연결하므로 추가/삭제 연산이 빠르다.

•  무작위 접근이 불가능하며, 순차 접근만이 가능하다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.002.png)

` `**[ 큐와 스택의 구현 ]**

•  큐(Queue): Array로 구현하면 poll 연산 이후 객체를 앞당기는 작업이 필요하다. 하지만 List로 구현하면 객체 1개만 제거하면 되므로 삽입 및 삭제가 용이한 LinkedList로 구현하는 것이 좋다.

•  스택(Stack): List로 구현하면 객체를 제거하는 작업이 필요하다. 하지만 Array로 구현하면 삭제할 필요 없이 index를 줄이고 초기화만 하면 되므로, Array로 구현하는 것이 좋다.

3\.네트워크

**[ 웹 동작 방식 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.003.png)



1\. 사용자가 브라우저에 URL을 입력

2\. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음

3\. HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함

4\. TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨

5\. 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함

6\. TCP/IP 연결을 통해 요청한 컴퓨터로 전송

7\. 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨


**[ TCP와 UDP 차이 ]**

TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정합니다. 그렇기 때문에 높은 신뢰성을 보장하지만 속도가 비교적 느리다는 단점이 있습니다. UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있습니다. 하지만 수신 여부를 확인하지 않기 때문에 속도가 빠릅니다. TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.004.png)

**[ GET과 POST 차이 ]**

GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다. URL에 데이터가 노출되기 때문에 보안적으로 중요한 데이터를 포함해서는 안됩니다.

POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다. 완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET보다는 안전합니다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.005.png)

**[ 공인 IP와 사설 IP 차이 ]**

•  공인 IP

•  전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소

•  외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능하다.

•  그에 따라 방화벽 등과 같은 보안 설정을 해주어야 한다.

•  사설 IP

•  어떤 네트워크 안에서 사용되는 IP주소

•  IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소이다.

•  별도의 설정 없이는 외부에서 접근이 불가능하다.

**[ 웹 접근성의 국제표준 ]**

웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미합니다. 웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정하였습니다.

**[ OSI 7계층 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.006.jpeg)

•  7 계층(응용 계층): 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층

•  6 계층(표현 계층): 데이터의 형식(Format)을 정의하는 계층

•  5 계층(세션 계층): 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층

•  4 계층(전송 계층): 최종 수신 프로세스로 데이터의 전송을 담당하는 계층

•  3 계층(네트워크 계층): 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층

•  2 계층(데이터링크 계층): 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층

•  1 계층(물리 계층): 데이터를 전기 신호로 바꾸어주는 계층

**[ HTTP 프로토콜이란? ]**

HTTP(Hyper Text Transfer Protocal)이란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다. HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동합니다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성됩니다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.007.png)

**[ HTTP vs HTTPS ]**

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. HTTPS에는 대칭키 암호화와 비대칭키 암호화가 모두 사용됩니다. 비대칭키 암/복호화는 비용이 매우 크기 때문에 서버와 클라이언트가 주고받는 모든 메세지를 비대칭키로 암호화하면 오버헤드가 발생할 수 있습니다. 그래서 서버와 클라이언트가 최초 1회로 서로 대칭키를 공유하기 위한 과정에서 비대칭키 암호화를 사용하고, 이후에 메세지를 주고 받을 때에는 대칭키 암호화를 사용합니다. 이러한 과정을 정리하면 다음과 같습니다.

. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함

. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌

. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함

. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함

. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음

. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함



공개키로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 서버(기업)을 제외한 누구도 원본 데이터를 얻을 수 없습니다.

**[ 3 Way-Handshake ]**

3 Way-Handshake란 TCP 네트워크에서 통신을 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신 이 가능한 상태임을 확인합니다.![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.008.png)

4\. 운영체제


**[ 메모리란 ]**

메모리는 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간입니다. 프로그램을 실행하기 위한 정보들은 메모리에 저장되어 처리됩니다.

**[ 프로세스와 쓰레드의 차이 ]**

•  프로세스

•  정의: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

•  특징

•  운영체제로부터 독립된 메모리 영역을 할당받는다. (다른 프로세스의 자원에 접근 X)

•  프로세스들은 독립적이기 때문에 통신하기 위해 IPC를 사용해야 한다.

•  프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.

•   쓰레드

•  정의: 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위

•  특징

•  쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다.
(Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.)

•  쓰레드는 프로세스의 자원을 공유하기 때문에 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.

•  프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행된다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.009.jpeg)

**[ 컨텍스트 스위칭(Context Switching)이란? ]**

Context Switching이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다. Context Switching는 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다. 여기서 인터럽트란 CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 말합니다.

**[ 컨텍스트 스위칭(Context Switching)이란? ]**

Context Switching이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다. Context Switching는 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다. 여기서 인터럽트란 CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에게 알리는 것을 말합니다.

**[ 데드락(DeadLock) 이란? ]**

데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다. 예를 들어 다음과 같은 상황에서 데드락이 발생할 수 있습니다.

자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됩니다.

**[ 멀티 쓰레드 프로그래밍 작성 시 유의점 ]**

멀티 쓰레드 프로그램을 개발한다면, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호 배제를 제거해 교착 상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 발생하지 않도록 주의해야 합니다.


` `**[ 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 ]**

뮤텍스는 Locking 메커니즘으로 락을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제할 수 있습니다. 하지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.

**[ CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법 ]**

이러한 문제를 해결하기 위해 메모리를 계층화하여 병목현상을 해결하고 있습니다. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있습니다.

**[ 가상메모리와 페이지폴트 ]**

가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다(Valid bit를 통해 확인). 이것을 페이지 폴트라고 하는데 프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다. 가상메모리는 하드디스크에 저장되어 있기 때문에, 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.

5\. Database

**[ 인덱스(index)란? ]**

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.

데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

만약 Index를 적용하지 않은 컬럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행된다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

**[ 인덱스의 자료구조 ]**

•  해시 테이블

•  컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.

•  시간복잡도가 O(1)이라 검색이 매우 빠르다.

•  부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.

•  B+Tree

•  자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.

•  BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.

•  해시 테이블보다 나쁜 O(log2n2) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.




**[ 트랜잭션(Transaction)이란? ]**

트랜잭션이란 데이터베이스 작업의 단위로써 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다.

**[ 트랜잭션의 ACID란? ]**

•  원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.

•  일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.

•  고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.

•  지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

**[ 이상 현상의 종류 ]**

•  삭제 이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상

•  삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상

•  수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상



**[ RDBMS와 NoSQL 차이 ]**

•  RDBMS

•  2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스 

•  장점: 스키마에 맞추어 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.

•  단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.

•  NoSQL

•  RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스

•  장점: NOSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리할 수 있다.

•  단점: 중복된 데이터가 추가 가능하여, 이에 대한 관리가 필요하다.



6\. 개발 언어(JAVA)

**[ Java의 장점과 단점 ]**

•  장점

•  JVM 위에서 동작하기 때문에 운영체제에 독립적이다.

•  가비지컬렉터가 메모리를 관리해주기 때문에 편리하다.

•  단점

•  JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.

•  다중 상속이나 타입에 업격하는 등 제약이 있는 것이 많다.


**[ Java가 다중 상속을 지원하지 않는 이유 ]**

다중 상속을 지원하면 다이아몬드 문제가 발생할 수 있기 때문입니다. 예를 들어 Human 클래스에 있는 walk() 메소드를 Female 클래스와 Male 클래스가 모두 구현하였다고 할 때, Female과 Male 클래스를 다중 상속 받은 Person 클래스의 입장에서는 코드의 충돌이 생기기 때문입니다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.010.png)

**[ 오버라이딩(Overriding)과 오버로딩(Overloading) ]**

•  오버라이딩(Overriding): 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의하여 사용하는 기술

•  오버로딩(Overloading): 매개변수의 타입과 개수를 변경하면서 같은 이름의 메소드를 여러 개 사용하는 기술

**[ 클래스(Class), 객체(Object), 인스턴스(Instance)의 개념 ]**

•  클래스(Class): 객체를 만들어내기 위한 설계도 혹은 틀

•  객체(Object): 설계도(클래스)를 기반으로 선언된 대상, 클래스의 인스턴스라고도 부름

•  인스턴스(Instance): 객체에 메모리가 할당되어 실제로 활용되는 실체

*// 클래스* public class Person {

` `Private String name;

` `} 

public class Main { 

public static void main(String[] args) { *// 객체 = 클래스의 인스턴스*

Person person; *// 인스턴스*

person = newPerson(); } 

}

**[ 싱글톤 패턴(Singleton Pattern) 구현 및 사용 이유 ]**

싱글톤 패턴은 단 하나의 인스턴스를 생성하여 사용하는 디자인패턴입니다. 싱글톤패턴은 아래의 경우에 사용합니다.

•  해당 인스턴스가 절대적으로 1개만 존재한다는 것을 보증하고 싶은 경우

•  동일한 인스턴스를 자주 생성해주어야 하는 경우(메모리 낭비의 방지)

하지만 이러한 싱글톤 패턴은 객체 지향 설계의 원칙에 적합하지 않으며, LifeCycle 제어가 힘들고, 멀티스레드 환경에서 여러 개의 객체가 생성되는 문제가 발생할 수 있습니다. 그러한 이유로 멀티스레드 환경이라면 static 앞에 synchronized 키워드를 붙여 동기화 작업을 추가해주어야 합니다.(당연히 성능이 저하됩니다).

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.011.png)

**[ 추상클래스와 인터페이스의 차이 ]**

•  추상클래스

•  단일 상속만이 가능하다.

•  모든 접근 제어자를 사용할 수 있다.

•  변수와 상수를 선언할 수 있다.

•  추상 메소드와 일반 메소드를 선언할 수 있다.

•  인터페이스

•  다중 구현이 가능하다.

•  public 접근 제어자만 사용할 수 있다.

•  상수만 선언할 수 있다.

•  추상메소드만 선언할 수 있다.



**[ Java의 List, Set, Map 차이 ]**

•  List

•  데이터를 순차적으로 저장한다.

•  데이터의 중복을 허용한다. 

•  데이터로 null을 허용한다.

•  Set

•  순서없이 Key로만 데이터를 저장한다.

•  Key의 중복을 허용하지 않는다.

•  Key로 null을 허용하지 않는다.

•  Map

•  순서없이 Key, Value로 데이터를 저장한다.

•  Value는 중복을 허용하지만 Key의 중복을 허용하지 않는다.

•  Key로 null을 허용하지 않는다.

**[ Java의 Vector와 ArrayList 차이 ]**

•  Vector

•  동기화를 지원한다.

•  속도가 느리지만 병렬 상황에서 안전하다.

•  크기가 증가하는 경우, 2배 증가함(10 -> 20)

•  ArrayList

•  동기화를 지원하지 않는다.

•  속도는 빠르지만 병렬 상황에서 안전하지 않다.

•  크기가 증가하는 경우, 1.5배 증가함(10 -> 15)

**[ Java의 StringBuffer와 StringBuilder 차이 ]**

•  StringBuffer

•  동기화를 지원한다.

•  속도가 느리지만 병렬 상황에서 안전하다.

•  StringBuilder

•  동기화를 지원하지 않는다.

•  속도는 빠르지만 병렬 상황에서 안전하지 않다.

` `**[ synchronized란? ]**

Java에서 지원하는 synchronized 키워드는 여러 쓰레드가 하나의 자원을 이용하고자 할 때, 한 스레드가 해당 자원을 사용중인 경우, 데이터에 접근할 수 없도록 막는 키워드입니다. synchronized 키워드를 이용하면 병렬 상황에서 자원의 접근을 안전하게 하지만, 자원을 이용하지 않는 쓰레드는 락에 의한 병목현상이 발생하게 됩니다.

•  메소드 synchronized: 한 시점에 하나의 쓰레드만이 해당 메소드를 실행할 수 있다.

•  변수 synchronized: 한시점에 하나의 쓰레드만이 해당 변수를 참조할 수 있다.




**[ Java8 ]**

Java8에서는 함수형 프로그래밍을 위해  함수형 인터페이스와 람다와 함께 stream API가 추가되었고, Null-safe한 작업을 위한 Optional API, Date와 Time을 함께 처리하기 위한 LocalDateTime API 등이 추가되었습니다.

` `**[ try-with-resources ]**

try-with-resources란 Java7 버전에 추가된 기능으로, 리소스를 다 사용한 객체를 자동으로 반납(close)해줍니다. try-with-resources를 사용하면 코드가 try-finally보다 유연해지며, try-finally에서와 달리 누락없이 모든 자원을 반납할 수 있습니다.

try-with-resources를 통해 객체가 자동으로 반납되기 위해서는 AutoCloseable 인터페이스를 구현하고 있어야 합니다. 

**[ Stream API의 장점과 단점 ]**

•  장점

•  코드를 간결하게 작성하여 가독성을 높일 수 있다.

•  병렬스트림과 같은 기술을 이용하면 처리 속도를 많이 높일 수 있다.

•  단점

•  잘못 사용하면 기존의 Java 방식보다 오히려 성능이 떨어질 수 있다.

•  코드들이 추상화되어 있어 실수가 발생할 수 있다.

**[ 람다(Lambda)와 람다(Lambda)의 사용법 ]**

람다는 불필요한 코드를 줄이고, 가독성을 높이기 위한 익명 함수로써, 함수의 이름과 반환타입 없이 손쉽게 함수를 선언할 수 있습니다. 람다는 아래와 같이 괄호와 화살표로 표현할 수 있으며, 람다의 반환값은 함수형 인터페이스이므로, 이를 이용해주어야 합니다.

**[ Java의 동작 과정 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.012.png)

1\. Java 소스 파일을 javac로 컴파일하여 class파일(Java 바이트 코드)을 생성함

2\. 클래스로더가 컴파일된 Java 바이트 코드를 런타임 데이터 영역(Runtime Data Areas)로 로드함

3\. 실행 엔진(Execution Engine)이 자바 바이트코드를 실행함

**[ JVM의 구조 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.013.png)

JVM의 구조 중 메모리 구조는 다음과 같이 구성됩니다.

•  Method Area(메소드 영역): 클래스 변수의 이름, 타입, 접근 제어자 등과 같은 클래스와 관련된 정보를 저장한다. 그 외에도 static 변수, 인터페이스 등이 저장된다.

•  Heap Area(힙 영역): new를 통해 생성된 객체와 배열의 인스턴스를 저장하는 곳이다. 가비지 컬렉터는 힙 영역을 청소하며 메모리를 확보한다.

•  Stack Area(스택 영역): 메소드가 실행되면 스택 영역에 메소드에 대한 영역이 1개 생긴다. 이 영역에 지역변수, 매개변수, 리턴값 등이 저장된다.

•  PC register(PC 레지스터): 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다.(CPU의 레지스터와 다르다.)

•  Native Method Stack(네이티브 메소드 스택): 자바 외의 언어(C, C++ 등)로 작성된 코드를 위한 메모리 영역이다. JNI를 통해 사용된다.



**[ 가비지 컬렉터(Garbage Collector)란? ]**

'더이상 참조되지 않는 메모리'인 가비지를 청소해주는 JVM의 실행 엔진의 한 요소입니다. JVM은 new와 같은 연산에 의해 새롭게 생성된 객체들 중에서 더이상 참조되지 않는 객체를 정리해줍니다. 가비지 컬렉터는 Heap 영역을 위주로 탐색하며 메모리를 정리해줍니다.

**[ 가비지 컬렉션(Garbage Collection)의 과정 ]**

가비지 컬렉션(GC)은 메모리를 정리하는 과정입니다. 그렇기 때문에 일반적으로 메모리의 사용을 중단한 채로 진행이 되어야 합니다. JVM은 GC를 실행하기 위해 애플리케이션의 실행을 멈추는 stop-the-world를 먼저 실행하게 됩니다. stop-the-world를 실행하면 GC를 실행하는 쓰레드를 제외한 모든 쓰레드가 작업을 멈춥니다. 그리고 GC가 끝나면 다시 작업을 재개합니다. GC의 작업은 Young 영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분됩니다.



•  Young 영역: 새롭게 생성한 객체들이 위치한다. 대부분의 객체는 금방 접근 불가능한 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라진다.

•  Old 영역: Young 영역에서 계속 사용되어 살아남은 객체가 복사되는 영역이다. Young 영역보다 크게 할당되며, 더 적은 GC가 발생한다.






7\. 백엔드

**[ WAS와 WS의 차이 ]**

•  WAS(Web Application Server)

•  비지니스 로직을 넣을 수 있음

•  Tomcat, PHP, ASP, .Net 등

•  WS(Web Server)

•  비지니스 로직을 넣을 수 없음

•  Nginx, Apache 등

**[ 많은 트래픽이 발생한 경우 대처하는 방법 ]**

•  스케일 업(Scale Up): 서버에 CPU나 RAM 등을 추가하여 서버의 하드웨어 스펙을 향상시키는 방법이다.

•  스케일 아웃(Scale Out): 서버를 여러 대 추가하여 시스템을 증가시키는 방법이다.

**[ CORS 란? ]**


CORS(Cross-Origin-Resource-Sharing)란 도메인이 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제입니다. 예를 들어 mangkyu.com에서 mang.com으로 데이터를 요청한다고 하면, 따로 설정을 해주지 않는 한 CORS 에러를 만나게 됩니다.

CORS가 생기게 된 이유는 서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해서인데, 요청을 허락하기 위해서는 Access-Control-Alow-Origin: {도메인} 과 같은 내용을 Response의 헤더에 추가해주어야 합니다다. 만약 도메인을 \*으로 설정하면 모든 도메인에 대해 요청을 허락할 수 있습니다. 그 외에도  Access-Control-Allow-Methods, Access-Control-Max-Age 등을 설정해줄 수 있습니다.

•  Access-Control-Allow-Orgin : 요청을 보내는 페이지의 출처 [ \*, 도메인 ] 

•  Access-Control-Allow-Methods : 요청을 허용하는 메소드. Default : GET, POST

•  Access-Control-Max-Age : 클라이언트에서 preflight 요청 (서버의 응답 가능여부에 대한 확인) 결과를 저장할 시간

•  Access-Control-Allow-Headers : 요청을 허용하는 헤더





**[ 아파치와 톰캣은 각각 멀티 프로세스인가 멀티 쓰레드인가? ]**

아파치는 기본적으로 멀티 프로세스로 구현되어 있다. 하지만 설정에 따라 멀티 쓰레드를 같이 운용할 수 있다.

톰캣은 요청을 처리하기 위한 쓰레드 풀을 관리하고 있다. 그리고 요청이 오면 해당 쓰레드 풀에서 쓰레드를 꺼내 요청을 처리하도록 한다.

**[ 디자인 패턴 ]**

•  생성 패턴

•  팩토리 패턴: 객체를 생성하기 위한 디자인 패턴

•  추상 팩토리 패턴: 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴

•  빌더 패턴: 상황에 따라 동적인 인자를 필요로 하는 객체를 생성하기 위한 디자인 패턴

•  싱글톤 패턴: 객체를 1개만 생성하여 항상 참조가능하도록 고안된 디자인 패턴

•  구조 패턴

•  어댑터 패턴: 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴

•  프록시 패턴: 어떤 객체에 접근 제어를 위해 대리인을 사용하는 디자인 패턴

•  데코레이터 패턴: 어떤 객체에 새로운 기능 추가를 위해 대리인을 사용하는 디자인 패턴

•  퍼사드 패턴: 어떤 복합적인 기능에 대해 간략화된 인터페이스를 제공하는 디자인 패턴

•  행위 패턴

•  전략 패턴: 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴

•  옵저버 패턴: 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴

•  커맨드 패턴: 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴

**[ Servlet(서블릿)이란? ]**

서블릿이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술입니다. Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환합니다.





**[ Spring 기초지식(DI, DL, IoC, AOP) ]**

•  DI(Dependency Injection): 한 객체에서 다른 객체를 필요로 하여 의존성을 갖게 하는 기술

•  DL(Dependency Look-up): 한 객체에서 필요로 하는 다른 객체를 찾아서 사용하는 기술

•  IoC(Inversion of Control): 직접 제어야하는 부분에 대한 권한을 프레임워크 등에 넘기는 기술

•  AOP(Aspect Oriented Programming): 공통의 관심 사항을 추출하여 원하는 곳에 적용하는 기술

**[ VO와 DTO, BO, DAO란? ]**

•  DAO(Data Access Object): DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스, Repository 또는 Mapper에 해당함

•  BO(Business Object): 여러 DAO를 활용해 비지니스 로직을 처리하는 클래스, Service에 해당함

•  DTO(Data Transfer Object): 데이터를 주고 받기 위해 사용하는 클래스

•  VO(Value Object): 실제 데이터만을 저장하는 클래스

**[ 디스패처 서블릿(Dispatcher Servlet)이란? ]**

디스패처 서블릿이란 톰캣과 같은 서블릿 컨테이너를 통해 들어오는 모든 요청을 제일 앞에서 받는 프론트 컨트롤러입니다. 디스패처 서블릿은 공통된 작업을 처리한 후에, 적절한 세부 컨트롤러로 작업을 위임해줍니다. 그리고 각각의 세부 컨트롤러는 처리할 부분을 처리하고 반환할 view를 Dispatcher Servlet에 넘기게 됩니다.

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.014.png)




**[ Spring에서의 싱글톤 패턴 ]**

Java로 기본적인 싱글톤 패턴을 구현하고자 하면 다음과 같은 단점들이 발생한다.

•  private 생성자를 갖고 있어 상속이 불가능하다.

•  테스트하기 힘들다.

•  서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다.

•  전역 상태를 만들 수 있기 때문에 바람직하지 못하다.


그래서 스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하는데, 이를 통해 다음과 같은 장점을 얻을 수 있다.

•  static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.

•  테스트를 하기 편리하다.


**[ MVC 패턴이란? ]**

MVC(Model-View-Controller)패턴은 아키텍쳐를 설계하기 위한 디자인 패턴입니다. 

MVC 패턴은 애플리케이션을 개발할 때 그 구성요소를 3가지로 나눕니다.

•  Model: 데이터를 저장하는 컴포넌트

•  View: 사용자 인터페이스(UI) 컴포넌트

•  Controller: 사용자의 요청을 처리하고 Model과 View를 중개하는 컴포넌트

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.015.png)

**[ Spring MVC란? ]**

Spring MVC란 웹 애플리케이션 개발을 위한 MVC 패턴 기반의 웹 프레임워크입니다. Spring MVC는 애플리케이션의 구성요소를 Model, View, Controller로 분리합니다. 또한 Spring MVC는 아래와 같은 컴포넌트들로 구성됩니다.

•  Dispatcher Servlet: 클라이언트의 요청을 먼저 받아들이는 서블릿으로, 요청에 맞는 컨트롤러에게 요청을 전달함

•  Handler Mapping: 해당 요청이 어떤 컨트롤러에게 온 요청인지 검사함

•  Controller: 클라이언트의 요청을 받아 처리하여 결과를 디스패처 서블릿에게 전달함

•  ViewResolver: View의 이름을 통해 알맞은 View를 찾음

•  View: 사용자에게 보여질 UI 화면

**[ Spring MVC 작동 원리 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.016.png)

1\. 클라이언트는 URL을 통해 요청을 전송한다.

2\. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.

3\. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.

4\. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.

5\. 컨트롤러는 비지니스 로직을 처리한 후에 반환할 뷰의 이름을 반환한다.

6\. 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾는다.

7\. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다.

8\. 데이터가 추가된 뷰를 반환한다.    

**[ Spring MVC의 장점과 단점 그리고 SpringBoot]**

•  장점

•  의존성 주입을 통해 컴포넌트 간의 결합도를 낮출 수 있어 단위테스트가 용이함

•  제어의 역전을 통해 빈(객체)의 라이프싸이클에 관여하지 않고 개발에 집중할 수 있음

•  단점

•  XML을 기반으로 하는 프로젝트 설정은 너무 많은 시간을 필요로 함

•  톰캣과 같은 WAS를 별도로 설치해주어야 함

•  해결책(Spring Boot)

•  자주 사용되는 라이브러리들의 버전 관리 자동화

•  AutoConfig로 복잡한 설정 자동화

•  Tomcat과 같은 내장 웹서버 제공

•  실행 가능한 JAR로 개발 가능

**[ Spring @Bean, @Configuration, @Component 어노테이션 ]**

•  @Bean: 개발자가 직접 제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 수동으로 빈 등록할 때 사용

•  @Configuration: 1개 이상의 @Bean 메소드를 갖는 클래스의 경우에 반드시 명시해 주어야 함

•  @Component: 개발자가 직접 개발한 클래스를 컴포넌트 스캔 방식으로 자동으로 빈 등록할 때 사용

**[ @SpringBootApplication ]**

•  @SpringBootConfiguration: @Configuration을 포함하고 있으며, 테스트 등을 위한 자동 설정을 위한 하기 위해 찾아짐

•  @EnableAutoConfiguration: 필요한 설정들을 자동으로 해주는 자동 설정 기능을 활성화함

•  @ComponentScan: 빈을 찾아서 등록하기 위한 위치를 지정함

` `**[ Spring Filter와 Interceptor의 차이 ]**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.017.png)



**[ 디스패처 서블릿 동작 방식 ]![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.018.png)**

. 클라이언트의 요청을 디스패처 서블릿이 받음

. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음

. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달함

. 핸들러 어댑터가 컨트롤러로 요청을 위임함

. 비지니스 로직을 처리함

. 컨트롤러가 반환값을 반환함

. HandlerAdapter가 반환값을 처리함

. 서버의 응답을 클라이언트로 반환함

**[ AspectJ AOP의 작동 원리 ]**

Spring AOP가 아닌 또 다른 강력한 AOP 프레임워크 중 하나인 AspectJ는 프록시를 이용하지 않았습니다. 대신 AspectJ는 타깃 클래스 파일의 바이트 코드를 조작하여 부가기능을 직접 넣어주는 방법(위빙)을 사용합니다. 그래서 우리가 만든 코드에서는 부가 기능이 분리되어 있지만 바이트 코드에서는 핵심 기능과 부가 기능이 섞여있는 구조입니다. AspectJ가 프록시를 사용하지 않고 어려운 복잡한 바이트 조작 방법을 사용하는 이유는 크게 2가지가 있습니다.

•  바이트 코드를 조작하면 Spring과 같은 컨테이너의 도움이 필요 없기 때문이다.

•  프록시 방식보다 훨씬 강력하고 유연한 AOP를 제공할 수 있다.




**[ Spring WebFlux란? ]**

Spring WebFlux란 Blocking+동기 방식으로 동작하는 Spring MVC의 한계점을 극복하기 위해 Spring5에 처음 등장하게 되었습니다. 기존의 Spring MVC에서는 HTTP 요청들을 큐에 넣어두고, 멀티쓰레드를 기반으로 동작하고 있습니다. 하지만 이러한 방식은 응답성이 상대적으로 떨어지기 때문에 비동기적으로 요청을 처리하기 위한 방법이 필요하게 되었고, 리액티브 프로그래밍을 통해 비동기 데이터 스트림으로 Non-Blocking 애플리케이션을 개발하기 위한 Spring WebFlux 프레임워크가 등장하게 되었습니다.

**[ CDN(Content Delivery Network)란? ]**

CDN(Content Delivery Network)는 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 고안된 기술입니다. 만약 우리나라에 있는 사람이 미국에 있는 서버로부터 이미지나 파일 등을 다운받으려고 하면 시간이 오래 걸립니다. 따라서 느린 응답속도와 다운로드 시간을 극복하기 위해 서버를 분산시켜 캐싱해두고, 빠르게 다운받을 수 있게 합니다.

CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾은 다음 엔드유저에게 응답을 전송합니다. 

**[ HTTP ]**

**HTTP(Hypertext Transfer Protocol) 은 처음엔 서버와 브라우저간에 데이터를 주고받기 위해 설계된 프로토콜이다. 지금은 브라우저 뿐 아니라 서버와 서버간의 통신할 때도 많이 이용합니다.**

**1. HTTP는 헤더를 통한 확장이 쉽다 ( 즉 헤더에 데이터를 추가하고 또 추가해서 보낼 수 있다는 것)**

**2. HTTP는 Stateless 하다**

` `**동일한 연결에서 연속적으로 수행되는 두 요청 사이에 연속적인 상태(state) 값은 없다. ( 상태를 저장하지않음 )**




**[ SSH ]**

**SSH(Secure Shell Protocol)는 보안되지 않는 네트워크에 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜이다.**

**[ SMTP ]**

**인터넷을 통해 메일을 보낼 때 사용되는 프로토콜(Simple Mail Trasfer Protocol) 보통 서비스를 운영하면 메일링 서비스를 하게 되는데 node.js를 통해 메일을 보낸다면 이를 통해 보냄**

**[ TCP 와 UDP ]**

**TCP , UDP 는 애플리케이션 계층에서 받은 메시지를 기반으로 세그먼트(TCP) 또는 데이터그램(UDP) 로 데이터를 쪼개고 데이터가 오류없이  순서대로 전달되도록 도움을 줌.**

**TCP - 가상회선패킷교환방식 사용, 3웨이 - 핸드쉐이크 로 연결 보장**

**순서대로 진행함**

` `**TCP의 오류검사 메커니즘** 

` `**재전송 : 시간 초과 기간이 지나면 서버는 전달되지않은 데이터를 재전송 시도**

` `**체크섬 : 체크섬을 통해 무결성을 평가. 송신된 데이터의 체크섬과 수신된 데이터의 체크섬값을 비교해서 올바르게 왔는지 확인**

**UDP - 데이터그램으로 데이터를 전송, 순서가 보장되지않음, 연결을 보장하지 않음**

` `**오류검사는 단순하게 체크섬만 진행**

**[ 라우팅 ]**

**라우팅(routing)은 네트워크에서 데이터를 보낼 때 최적의 경로를 선택하는 과정이며 라우터가 이를 수행합니다. 데이터를 보통 출발지에서 목적지로 가는 동안 여러 개의 라우터를 거치며 여러 번 라우팅을 수행합니다.( 라우팅은 보통 초당 수백만번 일어납니다.)**

**[ www.naver.com 입력시 화면이 나타나기까지 ]**

**대기열, 캐싱, DNS , 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운받게되고 브라우저 렌더링 과정을 거쳐 화면이 나타난다.**

` `**1. 대기열 - 브라우저는 주소창 입력에 대한 요청을 대기열에 넣는다.**

` `**2. 캐싱 - 캐싱은 요청된 값의 결과값을 저장하고 그 값을 다시 요청하면 다시 제공하는 기술. 공유프록시캐시와 브라우저  캐쉬로 나뉨**

**3.DNS - 브라우저가 요청의 IP주소를 확인하는 단계, DNS는 도메인 이름과 IP주소를 매핑해주는 서버. DNS 쿼리가 오면 [Root DNS] -> [.com DNS] -> [.naver DNS] -> [www. DNS] 과정을 거쳐 완벽한 주소를 찾아 매핑.**

` `**이때 바로 DNS서버로 요청을 전달하지않고 컴퓨터 메모리에 있는 호스트 파일 등 캐시를 확인한 후 캐시미스가 일어나면 DNS서버로 요청한다.**

**4. IP 라우팅 -> ARP : 서버 찾음**

**5. 초기 연결 - TCP 3웨이 - 핸드쉐이크 및 SSL 연결을 통해 연결을 설정, 이 후 요청을 보낸 후 해당 요청한 서버로부터 응답받음**

**6. 콘텐츠 다운로드 - 브라우저는 서버로 부터의 응답을 수신**

**7. 브라우저 렌더링**

**[로컬 스토리지와 세션 스토리지]**

**둘은 매우 유사합니다.** 

**세션 스토리지는 웹 스토리지 객체로 브라우저 내에 key value 형태로 오리진에 종속되어 저장되는 데이터를 말합니다.**

` `**로컬 스토리지도 마찬가지 이며**

` `**하나의 키에 오로지 하나의 값을 저장하며 최대 저장용량은 5MB 이다.**

**단 세션 스토리지는 브라우저에서 탭을 닫으면 데이터가 만료되며 로컬 스토리지는 만료되지않음. 주로 로컬 스토리지 많이 사용**

**둘의 차이는 만료 차이**

` `**주로 쿠키 vs 세션 vs 웹 스토리지 비교**

**쿠키와 세션은 HTTP 프로토콜의 비연결성 지향과 무상태 특성을 보완하려고 만들어진 것**

` `**1. 쿠키는 클라이언트(브라우져) 에 저장되는 키와 같이 들어있는 작은 파일**

` `**2. 세션은 사용자 정보를 파일로 저장하지 않고 서버측에서 관리 -> 브라우져 종료시 소멸**

` `**3. 웹 스토리지는 클라이언트에 데이터를 저장할 수 있도록 HTML5 부터 추가된 저장소.**

**ORIGIN 단위로 접근이 제한되며 같은 Storage 객체를 상속, Key - value 형태**

**[ 로컬스토리지, 세션스토리지, 쿠키의 공통점 및 차이점] ★★**

**공통점**

**1. 브라우저에 캐싱을 함으로써 서버에 대한 요청을 줄여 서버 부하를 방지할 수 있다.**

**2. 캐싱으로 인해 다운로드 하는 컨텐츠가 줄어들어 웹사이트의 컨텐츠를 더 빨리 다운로드 가능하다.**

**3. 사이트 기본 설정 커스터마이징( 색상, 글꼴, 크기 ) 등을 저장하거나 로그인을 유지할 때 사용될 수 있다.**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.019.png)

[ 토큰기반인증방식 ]

**토큰기반인증방식의 하나로서(access 토큰 , refresh토큰) 개념이 있다.**

**토큰기반인증방식은 인증은 토큰기반 인증서버를 통해 하고 다른 컨텐츠를 주는 서버는 Stateless하게 내버려두자는 이론이 담긴 인증 방식. 토큰은 주로 JWT이 활용**

**1. 인증로직 >> JWT 토큰 생성(access토큰, refresh 토큰)**

**2. 사용자가 이후에 access 토큰을 HTTP Header - Authorization 또는 HTTP - Cookie 에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져옵니다.**

**[ JWT란? ] ★★**

**Jason Web Token 을 의미하며 헤더, 페이로드, 서명(시그니쳐) 로 이루어져 있으며 JSON 객체로 인코딩 되며 메시지 인증, 암호화에 사용된다.** 

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.020.png)

**Header**

` `**- 어떠한 방법의 서명 알고리즘을 사용할 것인가에 대한 정보**

**Payload**

**- 데이터, 토큰 발급자, 토큰 유효기간**

**Signature**

` `**- 헤더에 정의된 알고리즘으로 인코딩된 Header + 인코딩된 Payload + 비밀키를 기반으로 생성된 서명값**

` `**토큰기반인증방식의 장점**

**장점**

**1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기 때문에 별도의 인증 저장소가 필요없음.**

**2. 다른 유형의 토큰과 비교했을 때 경량화되어있음. 다른 토큰으로 SAML이 있는데 이에 비해 훨씬 경량화되어있음.**

**3. 디코딩했을 때 JSON이 나오기 떄문에 JSON을 기반으로 쉽게 파싱 가능**

**단점**

**1. 토큰이 비대해질 경우 당연히 서버과부하에 영향을 줌.**

**2. 토큰을 탈취당했을 경우 디코딩했을 때 데이터를 볼 수 있음.**

**주의사항**

**- Bearer <token> 으로 Bearer 을 앞에 둬서 토큰기반인증방식이라는 것을 알려줘야 합니다.**

**- Https 를 사용해야 합니다.**

**- 쿠키에 저장하다면 SameSite: ‘Strict’ 를 써야합니다.**

**- 수명이 짧은 acces token을 발급해야 합니다.**

**- url 에 토큰을 전달하지말아야합니다.** 

**[ HTTP 상태코드 ]**

**1xx (정보)**

**서버가 요청을 잘 받았으며 해당 프로세스를 계속 이어가며 처리하는 것을 의미**

**- 100 : 계속함을 의미합니다.**

**2xx (성공)**

**서버가 요청을 잘 받았고 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미합니다.**

**- 200 OK : 요청이 성공적으로 되었습니다.**

**- 201 Created : 요청이 성공적이였으며 그 결과로 새로운 리소스가 생성되었습니다.**

**3xx (리다이렉션)**

` `**서버가 클라이언트 요청에 대해 완료를 위해 추가 작업 조치가 필요합니다.**

**- 301 Moved Permanently :  이 응답코드는 요청한 리소스의 URI가 변경되었음을 의미합니다. 변경된 새로운 URI를 301상태코드와 함께 줘야합니다.**

**4xx (클라이언트 오류)**

**클라이언트가 요청한 페이지를 제공할 수 없거나 클라이언트의 요청이 잘못되어 결과적으로 요청을 처리할 수 없는 상황**

` `**- 400 Bad Request : 서버가 클라이언트의 요청을 이해할수 없음을 의미합니다.**

` `**- 401 Unauthorized : 클라이언트의 인증이 되지 않음을 의미합니다.**

` `**- 404 Not found : 요청 받은 컨텐츠를 찾을 수 없다는 것을 의미합니다.**

**5xx (서버 오류)**

**서버가 클라이언트의 요청을 처리하지 못하는 상태**

**- 500 internal Server Error : 서버에 오류가 있음을 의미합니다.**

**- 502 Bad Gateway : 게이트웨이 또는 프록시 서버가 오류가 생겼음을 의미**

**- 504 Gateway Timeout : 게이트웨이 또는 프록시 서버가 정해진 Timeout 시간동안 클라이언트의 요청을 처리하지 못함을 의미합니다.**

**[ Get 과 Post의 차이 ]**

**Get : 데이터를 읽다**

**- url을 기반으로 데이터를 요청** 

**- 성공시 200코드 반환**

**- 캐싱 가능**

**- url 기반이기 때문에 해당 요청 파라미터가 브라우저기록에 남음**

**- 요청할 때 ASCII 문자열만 보낼 수 있다.**

**- 민감한 정보는 전달하지않는게 좋다**

**POST : 데이터를 생성하다**

**- URL이 아닌 HTTP Message body를 통해 데이터를 전달**

**- Body로 전달하기 때문에 데이터 길이 제한 없음**

**- 성공적으로 데이터를 생성할 경우 201코드 반환( 생성하지 않은 경우 200 반환 )**

**- 캐싱이 불가능**

**- 요청의 파라미터가 브라우저기록에 남지않는다.**

**- body로 요청하기 떄문에 ASCII 문자열 뿐 아니라 다른 데이터를 기반으로 요청 가능**

**[ Put 과 Patch ]**

**PUT : 업데이트하는 데이터의 전체를 보내다**

**요청을 보낼 때 해당 데이터 전체를 보내야 하고 전체 데이터의 교체를 의미한다.**

**또한 put은 만약 해당 데이터가 없다면 새로이 생성하고 있다면 해당 요청할 때 보낸 데이터와 교체를 진행**

**PATCH : 업데이트 하는 데이터의 일부를 보내다**

**요청을 보낼 떄 수정하는 일부분만 보내고 일부분의 교체를 의미한다.**

**[ API ]**

` `**API란? Application Programing interface**

` `**소프트웨어와 소프트웨어 사이 데이터 전송을 가능하게하는 프로그래밍**

**Rest API**

` `**웹의 장점을 잘 살린 아키텍처이며 먼저 이 아키텍처는 Uniform-interface를 갖는 것이 특징입니다.**

` `**자원, 행위, 표현 으로 이뤄져있음**

**Uniform-Interface**

**- 자원들이 각각 독립적인 인터페이스를 가져야 합니다.**

` `**1. 웹페이지를 변경했다고 업데이트하는 일은 없어야 하며**

` `**2. HTTP 명세나 HTML 명세가 변경되어도 웹페이지는 잘 작동해야 한다.**

**REST API의 URI 규칙 (restful 한 api)**

**1. 동작은 HTTP 메소드로 해야 한다. 즉 행위를 포함하지않는다** 

**2. 확장자는 표기하지 말아야한다.**

**3. 동사가 아닌 명사로만 표기한다.**

**4. URI는 계층적인 내용을 담고있기 때문에 집/아파트/전세 이런식으로 내려간다.**

**5. 소문자로 쓰며 너무 길 경우 \*\*-\*\* 사용**

**6. HTTP 응답 상태코드를 활용한다.**

**[ 대규모 트래픽으로 인한 과부하 해결법 ]**

**서버 과부하의 의미** 

**- 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할 때 발생합니다. 이 때 서버는 사용자의 웹 요청을 처리하지 못해 응답없음 이 뜨게 됩니다. ( 503 에러 발생)**

**1. 모니터링을 통한 자원 할당**

` `**- AWS 오토 스케일링 등을 사용하여 모니터링을 통한 자원의 적절한 할당으로 해결**

**2. 로드 밸런서 사용**

` `**- 로드 밸런서를 사용하여 트래픽을 분산시킴**

**3. 블랙스완 프로토콜**

` `**- 시스템 다운 시 블랙스완 프로토콜을 발령하여 다음과 같은 수칙을 따른다.**

**1. 영향을 받은 시스템과 각 시스템의 상대적 위험수준 확인, 체계적 데이터를 수집하고 원인에 대한 가설을 수립 후 테스팅**

**2. 잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락**

**3. 최대한 빨리 취약점에 영향을 받는 모든 시스템 패치**

**4. 복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달**



**[ 운영 체제의 역할 ]** 

**1.CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리합니다.**

**2. 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당할지 관리합니다.**

**3. 디스크 파일 관리 : 디스크 파일을 어떠한 방법으로 보관할지 관리합니다.**

**4. I/O 디바이스 관리 : I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.**

**[ 프로그램과 프로세스 그리고 스레드의 차이 ]**

**프로세스 - 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업(Task) 라는 용어와 거의 같은 의미로 사용됨. (싱글 스레드 프로세스 : 하나의 스레드만  , 멀티스레드 프로세스 : 여러 개의 스레드를 가진 프로세스 )** 

**스레드 - 프로세스 내 작업의 흐름을 지칭합니다.( 실행 가능한 가장 작은 단위)**

` `**프로세스는 코드, 데이터, 스택, 힙 메모리 영역을 기반으로 작업하는 반면 스레드는 프로세스 내의 스택 메모리 영역을 제외한 다른 메모리 영역을 프로세스 내 다른 스레드들과 공유합니다.**

` `**프로세스는 코드, 데이터, 스택, 힙 메모리 영역을 기반으로 작업을 하는 반면**

`  `**차이점**

**프로세스가 다른 프로세스와 통신을 하기 위해서는 IPC를 사용해야 하지만 스레드는 메모리를 공유하기 때문에 정보공유가 쉬움.**

` `**그러나 스레드는 동기화 문제등 단점이 존재.**

**스레드는 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있기 때문에 중단되지 않은 빠른 처리 가능, 동시성에도 큰 장점**

` `**그러나 문제 생기면 다른 스레드에도 영향을 줄 수 있는 단점 존재**


**[ 자바 컴파일 과정 ]**

**1. 사용자가 java코드를 작성 후 빌드함**

**2. 자바컴파일러(Javac) 는 자바파일 -> 바이트코드(.class) 파일로 변환함 ( 바이트코드는 어셈블리언어 형식)**

**3. Class Loader 에서 2번에서 생성된 바이트코드를 JVM 메모리에 로드 -> 실행**

**[ 멀티 프로세싱과 멀티 스레딩 , IPC ]**

**멀티 프로세싱**

` `**멀티 프로세싱은 여러 개의 ‘프로세스’ 즉 멀티프로세스를 통해 동시에 2가지 이상의 일을 수행할 수 있는 것을 말합니다. 이를 통해 하나 이상의 일을 병렬로 처리할 수 있으며 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생하더라도다른 프로세스를 이용해서 처리 가능 하므로 신뢰성이 높은 강점이 있습니다.**

**멀티스레딩**

**멀티스레딩은 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법이며, 스레드 끼리 서로 자원을 공유하기 때문에 효율성이 높다. 한 스레드가 중단되어도 다른 스레드는 실행 중 이기 때문에 중단되지 않은 빠른 처리가 가능하며 동시성에도 큰 장점을 가집니다. 그러나 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐**

**스레드로 이루어져있는 프로세스에 영향을 줄 수 있는 단점 존재**

**멀티프로세스 의 대표적인 예 : 웹 브라우저 가 멀티프로세스 구조**

**멀티스레드 의 대표적인 예 : 웹 브라우저의 렌더러 프로세스**

**[ 캐시 ]**

**캐시는 데이터를 미리 복사해놓는 임시 저장소이자 빠른 장치와 느린 장치에서의 속도 차이에 따른 병목현상을 줄이기 위한 메모리를 말한다. 계산된 값을 저장해서 다시 계산하지 않게 하는 장치 또는 메모리로도 의미가 쓰입니다.**

**실제로 메모리와 CPU 사이의 속도차이가 너무나 크기 때문에 (cpu가 훨씬 빠름) 그 중간에( CPU와 메인메모리RAM) 사이에 위치한 고속 기억장치( = 캐시메모리 ) 를 둬서 속도차이를 해결한다.**

` `**캐시는 임시 기억장치 이고 레지스터는 연산에 사용되는 데이터를 기억하는 소규모 기억 장치**


**[ ERD ]**

**ERD(Entity Relationship Diagram) 은 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며 릴레이션 간의 관계들을 정의한 것.**

**[ 트랜잭션 ]**

**트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 데이터베이스에 접근 하는 방법은 쿼리이므로, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다.**
**


**커밋이란?**

**커밋 - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어입니다. 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다. “커밋이 수행되었다” 를 하나의 트랜잭션이 성공적으로 수행되었다 라고도 말합니다. update insert delete 쿼리가 하나의 트랜잭션 단위로 수행되고 이후에 데이터베이스에 영구 저장 됩니다.**

**롤백이란?**

` `**트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 되돌리는 일(취소) 를 말합니다.**

` `**이러한 커밋과 롤백 덕에 데이터의 무결성이 보장된다. 또한 데이터 변경 전에 변경 사항을 쉽게 확인 할 수있고 해당 직업을 그룹화할 수 있습니다.**

**[ 트랜잭션 전파 ]**

**트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 합니다. 이를 매번 넘겨주기가 어렵기도하고 귀찮기도 하죠. 이를 넘겨서 수행하지않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 합니다. ( 싱글톤 패턴 생각하면 된다.)**

**[ 트랜잭션의 4가지 특성 ]**

**1. 원자성 - 원자성(Atomicity)은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징(실패하든 성공하든 둘중 하나). 예를 들어 트랜잭션을 커밋했는데 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장하는 것을 의미.**

**2. 일관성**

` `**일관성(Consistency)은 ‘허용된 방식’ 으로만 데이터를 변경해야하는 것을 의미. 데이터베이스에 기록된 모든 데이터는 여러 가지 조건 , 규칙에 따라 유효함을 가져야 한다.**

` `**즉 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야한다.**

**3. 격리성**

` `**격리성(Isolation) 은 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말합니다. 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적을 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 합니다. 즉 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다는 뜻.**

**4. 지속성**

` `**지속성(Durability)**

**지속성(Durability) 은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미합니다. 이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복기능이 있어야 함을 의미하며 DB는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공합니다.**
**


` `**체크섬 : 중복검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법**

` `**저널링 : 파일시스템 또는 데이터베이스의 시스템에 변경 사항을 반영(Commit) 하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것.**

**[ 무결성 ]**

` `**무결성**

` `**무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실세계의 실제 값이 일치하는지에 대한 신뢰가 생깁니다.** 

**무결성의 종류는 4가지 있다 (알고만 있자 외울필요없는 듯)**

` `**1. 개체 무결성 - 기본키로 선택된 필드는 빈 값을 허용하지 않는다**

` `**2. 참조 무결성 - 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일련된 값을 유지해야 한다.**

` `**3. 고유 무결성 - 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가집니다.**

` `**4. NULL 무결성 - 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건입니다.**

**[ 관계형데이터베이스 , NoSQL ]**

**관계형 데이터베이스(RDBMS) 는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며**

` `**SQL 이라는 언어를 써서 조작합니다.**

**NoSQL (Not only SQL)이라는 슬로건에서 생겨난 데이터베이스입니다. SQL을 사용하지 않는 데이터베이스를 말하며 유연한 스키마와 확장성이 특징입니다. 대표적으로 MongoDB , Redis 가 있습니다.**

**[ NoSQL 몽고DB 특징과 Redis 특징 ]**   

`  `**\*스키마란?:DB의 구조와 제약조건에 관한 전반적인 명세를 기술한 메타데이터 집합**

**MongoDB - JSON을 통해 데이터에 접근할 수 있고 Binary JSON(BSON) 형태로 데이터가 저장됨.**

**키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스. 스키마를 정해놓지 않고 데이터를 삽입.**

**Redis - in-memory 데이터베이스 이자 키-값 데이터 모델 기반의 데이터베이스입니다.**

` `**기본적인 데이터 타입은 문자열이며 최대512mb까지 저장 가능.**

**Pub/sub 기능을 통한 채팅시스템, 다른 DB앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션정보 관리 실시간 순위표 서비스 등에 사용합니다.**




**[ Index 인덱스 ]             \* B-tree : 자식 노드가 3개이상인 것을 말함 , 이진 트리 :자식노드 2개**

**인덱스란? 데이터를 빠르게 찾을 수 있는 하나의 장치입니다.  B-Tree 기반으로 구축되어 있기 때문에 트리 생성시 대수확장성 이란 특징으로 인해 더 빠른시간 안에 많은 데이터를 빠르게 찾을 수 있기 때문**

**인덱스 최적화 기법**

**1. 어떠한 값과 같음을 비교하는 == 이나 equal 하는 쿼리가 있다면 제일 먼저 인덱스로 설정**

**2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정.**

**3. 다중 값을 출력해야하는 필드, 즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력 해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정.**

**4. 유니크한 값의 정도를 카디널리티 라고 합니다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성.**

` `**예를 들면 age 와 email 이 있다고 가정하면 둘중 email이 더 높기 때문에 email 필드에 대한 인덱스를 먼저 생성하는 것.**

**[ 데이터베이스 정규화과정 ]**

**정규화 과정은 릴레이션 간의 잘못된 함수종속 관계로 인해 데이터베이스에 이상 현상이 일어나는 것을 해결하는 과정이자 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정 - 간단하게 테이블을 나누는 과정이라고 생각하면 된다.**

` `**[ 이상 현상 ]**

**이상현상 ( Anomaly ) 는 데이터베이스의 설계를 잘못하게 되었을때 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터의 삽입, 갱신, 삭제, 연산을 수행할 때 부작용이 발생하는 것을 말한다.**

**주로 테이블을 나누지않고 한 테이블에 몰아넣을 때 발생함. 예를들어 회원 정보랑 이벤트참여여부 등등 한곳에**

**삽입이상 - 불필요한 데이터가 들어가는 경우. null값이 들어간다던가 등**

**갱신이상 - 중복 레코드가 있고 이 중 일부만 변경해 데이터 자체가 불일치하는 문제**

**삭제이상 - 레코드를 삭제하는데 필요한 데이터까지 함께 삭제되는 문제**

` `**이렇게 관련없는 속성들이 하나의 릴레이션에 모였을 때 발생하는게 이상현상인데 이를 해결하는 척도가 바로**

**함수종속 이다. 관련성을 함수 종속성을 통해 파악하고 이를 기준으로 릴레이션을 분리하는 정규화 과정을 진행해야 함.**

` `**정규화는 필요할까? ->**

` `**조인을 계속 해야하기 때문에 오히려 느려질수도 있기 때문에 서비스에 따라 정규화, 비정규화 과정을 진행해야 한다.** 

**정규화 과정은 중복 데이터가 제거됨에 따라 스토리지에 대한 전체 메모리 요구량이 감소하게 된다.**

` `**또한 테이블이 더 정상적이게 되므로 오류 발생 확률 줄어듬. 다만 조인이 많이 발생한다면 어느정도 비정규화도 필요 ( 조인 쿼리는 가장 높은 비용이 듬 )**

**[ 자료구조 ]**

**자료 구조(Data structure)는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합이다.** 

**어떤 비즈니스로직을 처리할 때 그 로직에 가장 효과적인 자료구조를 찾아서 쓰는 것이 중요하다.**

**[ 시간 복잡도 ]**

**시간복잡도란 입력크기에 대해 어떤 알고리즘이 실행되는데 걸리는 시간이며 주요 로직의 반복횟수를 중점으로 측정된다.**

` `**시간복잡도 필요한 이유 - 효율적인 코드를 짜는 기준이 됨.**

**[ 공간 복잡도 ]**

**공간복잡도는 “입력크기에 대해 어떠한 알고리즘이 실행되는데 필요한 메모리 공간의 양” 을 가르킨다. 이는 정적변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함하며 배열이든 맵이든 셋이든 이 요소들을 담을 공간이면 다 적용된다.**

**[ 정적배열 (Array) ]**

**배열은 정적배열(Array) 와 동적배열(Vector) 가 있다.**

` `**정적배열은 선언할 때 보통 크기를 설정해서 연산을 진행하며 연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자 인덱스를 기반으로 랜덤접근이 가능하며 중복을 허용합니다.**

` `**\*랜덤접근 : 그니까 배열 a[1] , a[3] 처럼 임의의 값을 정하고 거기에 접근 가능하다는 것**

**[ 동적배열 (Vector) ]**

**vector는 동적으로 요소를 할당할 수 있는 동적 배열입니다. 만약 컴파일 시점에 사용해야 할 요소들의 개수를 모른다면 Vector를 써야 합니다. 연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자 인덱스를 기반으로 랜덤접근이 가능하며 중복을 허용합니다.**

**[ Likend List ]**     

**\* 노드 : 데이터저장 단위 (데이터 값, 포인터)로 구성 \* Pointer : 각 노드안에서 다음이나 이전 노드와의 연결정보를 가지고 있는 공간**

**연결리스트는 노드로 감싸진 요소를 인접한 메모리 위치가 아닌 독립적으로 저장하여 각 노드는 Next, 또는 NEXt,prev 라는 포인터로 서로 연결된 선형적인 자료구조 이다. 즉 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터.** 

**장점 - 데이터 공간을 미리 할당하지 않아도 된다. ( 배열의 경우 미리 데이터 공간을 할당해야함.)**

**단점 - 연결을 위한 별도의 데이터 공간이 필요하므로 저장공간 효율이 높지않다.**

`     `**- 연결 정보를 찾는 시간이 필요하므로 접근(참조) 속도가 느리다. (랜덤접근(직접접근)이 안됌)**

`     `**- 중간 데이터 삭제 시 앞-뒤 데이터의 연결을 재구성해야하는 부가적인 작업이 필요하다.**


**[ 배열과 연결리스트의 차이 ]★**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.021.png)


||배열|연결리스트|
| :-: | :-: | :-: |
|메모리 공간|연속된 메모리 공간에 쌓임 ( 순차적 )|연속되지않은 메모리 공간에 쌓임 (독립적)|
|삽입,삭제 (맨끝,맨앞제외)|삽입/삭제가 오래걸림.|삽입/삭제가 용이하다 ( 끊고 다시 연결 )|
|n번째 요소 참조|랜덤 접근이 가능하기 때문에 빠름|순차접근을 해야하기 때문에 느림|
|공간|데이터 공간을 미리 할당해야함|데이터 공간을 할당하지않아도 됌.|

` `데이터 추가와 삭제를 많이 하는 것은 연결 리스트 , 참조를 많이 하는 것은 배열로 하는 것이 좋다.

` `**[ 스택 ]**

**스택은 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질인 후입선출(LIFO, Last in First Out) 을 가진 자료구조를 말합니다. 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 사용됩니다.**

**[ 큐 ]**

**큐(Queue) 는 먼저 집어넣은 데이터가 먼저 나오는 성질인 선입선출(FIFO, First In First Out)을 지닌 자료구조 이며 나중에 집어넣은 데이터가 먼저 나오는 스택과는 반대의 개념. CPU작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비우선 탐색, 캐시 등에 사용된다.**

` `**예를들면 티켓팅 할떄 몇 명대기중입니다~ 이런게 큐를 기반으로 만든 로직**


` `**[ 트리 ]     \* 그래프 - 정점과 간선의 집합**

**트리는 자식노드와 부모노드로 이루어진 계층적인 구조를 가지며 무방향 그래프의 일종이자 사이클이 없는 자료구조를 의미합니다.** 

` `**부모 자식 계층 구조를 가진다. 같은 경로상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 됩니다.**

` `**V - 1 = E 라는 특징이 있다. 간선 수는 노드 수 -1 이라는 소리. ( V = Vertex (정점), E= Edge (간선) )**

**트리로 이루어진 집합을 숲(Forest) 이라고 합니다.**

**[ 이진 트리 (BT, Binary Tree) ]**

` `**각각의 노드의 자식노드 수가 2개 이하로 구성되어있는 트리를 의미합니다.**

**[ 이진 탐색 트리 ]**

` `**이진 트리의 일종으로 노드의 오른쪽 하위 트리에는 “노드의 값보다 큰 값” 이 있는 노드만포함되고 왼쪽 하위트리에는 “ 노드의 값 보다 작은 값” 이 들어있는 트리를 말합니다.**
**


**개발바닥 질문** 

**HttpSession을 사용시 session key는 하나인데 어떻게 구분해서 가져올까?**

**@AutoWired** 

**HttpSession session;**

` `**@PostMapping("/")** 

**public void create(Useruser) {**

**session.setAttribute("createdUser",user**

**);**

**이런 코드가 있을 때, createdUser 라는 하나의 문자열을 key로 사용하여 A유저, B유저 모두 같은 key값으로**

**user에 접근해서 사용할텐데 어떻게 사용자마다 구분된 세션을 사용하는지? ->**

**Session 은 각 클라이언트마다 하나씩 생성되어 제공되기 때문이다. 세션은 클라이언트 별로 각각의 상태 정보를 서버에서 저장하는 기술이다. 브라우저 종료까지 유지된다.**

**세션에서는 식별이 가능한 고유값을 생성하고 서버는 그 값을 갖고 구분한다.**

**그렇기 때문에 다른 결과값을 받을 수 있는 것.**

` `**세션과 쿠키는 하는 일과 목적은 같지만 쿠키는 클라이언트에 저장하고 세션은 서버에 저장된다.**

**쿠키는 사용자의 민감한 정보를 다루는 것은 매우 위험하다 예를들면 쇼핑몰 장바구니로 사용하는 정도가 옳다.**

**세션은 default 30분 저장됨**

**[ JPA의 n+1문제- fetchjoin 사용 ]**

**N + 1 문제란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미한다.**

**언제 발생? - JPA Repository를 활용해 인터페이스 메소드를 호출할 시 ( Read 시 )**

**누가 발생? - 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생**

**어떻게 발생?- JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우**

`           `**- JPA Fetch 전략이 Lazy 전략으로 데이터를 가져온 이후 연관관계인 하위 엔티티를 다시 조회하는 경우**

**왜 발생? - JPARepository 로 Find시 실행하는 첫 쿼리에서 하위 엔티티까지 한번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에.**

`         `**- JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL 만 가지고 SQL을 생성하기 때문에.**

` `**EAGER( 즉시 로딩 )인 경우**

**1. JPQL에서 만든 SQL를 통해 데이터 조회.**

**2. 이후 JPA 에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회**

**3. 2번의 과정으로 N+1 문제 발생**

**LAZY( 지연로딩 ) 인 경우**

**1. JPQL에서 만든 SQL을 통해 데이터를 조회**

**2. JPA에서 Fetch전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음.**

**3. 하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생**


**\* EAGER ( 즉시 로딩 )**

**즉시로딩은 항상 외부조인(Outer Join)을 사용한다. ( 외부 조인보다 내부 조인(Inner Join)이 성능최적**

**화에 유리) , @ManyToOne 일시 Fetch Default 가 EAGER타입**

**특정 엔티티를 조회할 떄 연관된 모든 데이터를 같이 로딩하는 것을 즉시 로딩 (EAGAR) 이라고 한다.**

**실무에서 엔티티 간의 관계가 복잡해질수록 조인으로 인한 성능 저하를 피할수 없으며 JPQL에서 N + 1 문제를 일으킨다.**

` `**즉시로딩은 불필요한 조인까지 포함해 처리하는 경우가 많기 때문에 ‘지연 로딩’ 사용을 권장하고 있다.**

**\* Lazy ( 지연 로딩 )**

**지연로딩은 연관된 엔티티를 실제 사용하는 시점에 데이터베이스에서 조회한다. LAZY 로딩 사용 시 N+1 문제가 발생하지 않는 것처럼 보이지만 마찬가지로 연관 관계의 하위 객체를 사용하려고 하면 N + 1 문제가 발생한다.**
**


**N + 1 문제를 해결하기 위해선 Fetch Join,  Batch Size 방법**

**1. Fetch Join ( JPQL의 성능 튜닝을 위해 제공되는 조인임. 기존의 SQL조인과 다름 )**

**JQPL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법이다.**

**@Query 어노테이션을 사용하여 Join Fetch문 추가.**

**2. Batch Size**

**Batch size를 정해줌으로서 피해를 최소화 한다.**

**[ CI / CD ]**

**지속적 통합/ 지속적 배포 라는 뜻**

**애플리케이션 개발 단계부터 배포떄 까지의 모든 단계를 자동화를 통해서 좀 더 효율적이고 빠르게 사용자에게 빈번히 배포할 수 있는 것을 말한다.**

**애플리케이션 개발 단계를 자동화 하여 애플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법이다.**



**[ ORM ]**

**ORM은 Object Relational Mapping(객체-관계-매핑)의 약자이다. ORM은 객체와 데이터베이스의 관계를 매핑해주는 도구이다.**

` `**JPA의 Hibernate 가 이 ORM에 해당하고, Mybatis 또한 ORM중 하나이다.**

**[  객체 지향 프로그래밍(OOP)의 4가지 특징 ]**

**\*객체 : 모든 실재하는 대상**

**객체 지향 프로그래밍의 특징 4가지**

**1. 추상화**

**- 사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것** 

**Ex)지하철 노선도**

` `**자바에선 추상 클래스와 인터페이스로 추상화를 구현한다.**

**2. 상속**

**- 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소를 말한다. - 재사용성 증가, 반복 코드 최소화**

**Ex) 메소드 오버라이딩 으로 상속 구현  오버로딩 도 상속을 구현한 것** 

**3. 다형성**

**어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질을 의미**

**Ex) 메서드 오버라이딩과 메서드 오버라이딩이 그 예시.**

**같은 이름의 메서드가 재정의되어서 상황에 따라 다른 역할을 할 수있음**

` `**또한**

**한 타입의 참조변수가 여러 타입의 객체를 참조할 수 있도록 하는것도 다형성의 예.**

**상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것 역시 다형성의 예 이다.**

**Ex) 리스트를 구현할떄 List 로 구현하면 ArrayList , LinkedList 둘다 사용 가능한점**

**4. 캡슐화**

` `**외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록 하여 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적**

**자바에서 캡슐화를 구현하기 위한 방법은 두가지인데,**

` `**Ex) 접근제어자를 활용하여 해당 클레스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한.**

![](Aspose.Words.192f098c-9d81-4ca4-94fa-a9b27b3f4dac.022.png)

**[ 제네릭 Generic ]** 

**제네릭 타입을 사용하는 이유는 무엇일까? - 중복제거와 타입 안정성을 동시에 추구함**

**1. 컴파일 단계에서 에러를 잡을 수 있다** 

**- 잘못된 객체를 넣을 시 컴파일 단계에서 걸러주어 런타임 단계에서 문제가 발생 될 여지를 막아준다.**

**2.타입 변환을 제거** 

**- 불필요한 타입 변환을 방지, 타입 캐스팅을 컴파일러가 해준다.**

**3. 재사용성 증가**

**- 오버로딩을 할 필요없이 코드라인 수를 줄일 수 있고 재사용성을 높힐 수 있다.**

**번외: <?> (와일드 카드 : Wild Card)**

**와일드카드<?>는 <? extends Object> 와 마찬가지.**

**[ Javascript의 Hoisting ]**

**Hoist 라는 단어의 사전적 정의는 끌어올리기 라는 뜻이다. 자바스크립트에서 끌어올려지는 것은 변수이다. var keyword로 선언된 모든 변수는 호이스트 된다. 호이스팅이란 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다. 즉 변수가 함수 내에서 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변경이 된다.**



